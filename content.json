{"meta":{"title":"blingfeng","subtitle":"blingfeng的博客","description":null,"author":"高峰","url":"http://www.blingfeng.cn"},"pages":[{"title":"Categories","date":"2017-09-29T09:57:32.403Z","updated":"2017-09-29T09:57:32.403Z","comments":true,"path":"categories/index.html","permalink":"http://www.blingfeng.cn/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-09-29T09:57:32.403Z","updated":"2017-09-29T09:57:32.403Z","comments":true,"path":"about/index.html","permalink":"http://www.blingfeng.cn/about/index.html","excerpt":"","text":""},{"title":"Categor","date":"2014-12-22T04:39:04.000Z","updated":"2017-09-29T09:57:32.403Z","comments":true,"path":"category/index.html","permalink":"http://www.blingfeng.cn/category/index.html","excerpt":"","text":""},{"title":"category","date":"2017-06-25T11:34:15.000Z","updated":"2017-09-29T09:57:32.403Z","comments":true,"path":"category/index-1.html","permalink":"http://www.blingfeng.cn/category/index-1.html","excerpt":"","text":""},{"title":"","date":"2017-09-29T09:57:32.434Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"project/index.html","permalink":"http://www.blingfeng.cn/project/index.html","excerpt":"","text":"项目(github) 1.E3商城(ssm框架):点击查看 (已完成) 2.bling云盘(ssm框架):点击查看 (已完成)点击进入bling云盘"},{"title":"Tags","date":"2017-09-29T09:57:32.434Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"tags/index.html","permalink":"http://www.blingfeng.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring下的Shiro权限框架","slug":"Spring下的Shiro权限框架","date":"2017-10-20T00:33:16.000Z","updated":"2017-10-20T03:57:24.791Z","comments":true,"path":"2017/10/20/Spring下的Shiro权限框架/","link":"","permalink":"http://www.blingfeng.cn/2017/10/20/Spring下的Shiro权限框架/","excerpt":"","text":"今天项目刚好需要权限管理功能，于是就找了两个开源的权限管理框架 Spring Security 和 Shiro。Spring Security是一款功能很强大的一款安全管理框架 而Shiro是一款小巧而功能齐全的一款安全管理框架。Shiro基本可以实现我们的功能，那就先了解下Shiro的具体使用吧，Spring Security在Shiro的学习之后会变得更加清晰。 一，导入依赖我使用的Shiro是1.2.2版本的，导入核心包和web包，缓存包以及Shiro与Spring整合包123456789101112131415161718192021&lt;!--apache shiro --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; 二、重写方法Shiro自己有一套令牌适配的，和权限密码效验的方法。但是我们项目中密码使用的是md5加密，Shiro并不知道我们密码采用怎样的加密方式，因此，我们应重写它的方法。 首先创建一个MyCredentialsMatcher类，直接继承SimpleCredentialsMatcher类，然后重写它的doCredentialsMatch方法。12345678910111213141516171819202122public class MyCredentialsMatcher extends SimpleCredentialsMatcher &#123; /** * 该方法获取用户角色以及权限的对象 以及数据库中的正确用户密码 * token中存储用户表单中输入的用户名密码等信息 */ @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token; /**md5加密前的密码*/ String password = String.valueOf(usernamePasswordToken.getPassword()); /** token令牌 将密码MD5加密 */ Object tokenCredentials = DigestUtils.md5DigestAsHex(password.getBytes()); /** 账户令牌 该方法可获取之前存储的密码*/ Object accountCredentials = getCredentials(info); try &#123; return equals(tokenCredentials, accountCredentials); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 从token中取出我们前端传入的密码，然后md5加密后与AuthenticationInfo中的密码，也就是数据库查出的密码比较。 做了这上面后还不够，我们应该还要告诉Shiro用户对应密码，才能在之前重写的方法中获取到密码。 同样的，我们继承AuthorizingRealm这个方法，然后重写他的doGetAuthorizationInfo和doGetAuthenticationInfo方法 12345678910111213141516171819202122232425262728293031323334protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String) principalCollection.getPrimaryPrincipal(); User user = userService.selectUserByUsername(username); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); /** * 查询该用户的角色以及角色所拥有的所有权限 */ for (Role role : user.getRoleList()) &#123; authorizationInfo.addRole(role.getRole()); for (Permission permission : role.getPermissionList()) &#123; authorizationInfo.addStringPermission(permission.getPermission()); &#125; &#125; return authorizationInfo; &#125; /** * 用户登陆认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken; String username = usernamePasswordToken.getUsername(); User user = userService.selectUserByUsername(username); if(user==null)&#123; return null; &#125;else&#123; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,user.getPassword(),this.getName()); SecurityUtils.getSubject().getSession().setAttribute(\"userInfo\",user); return authenticationInfo; &#125; &#125; 上面那个方法，是根据用户名查询到用户的所有角色和权限。该方法只会在有权限验证或者@RequiresPermission()注解时才会调用。 下面那个方法，是获取前端传入的用户名密码，然后根据用户名，从数据库中查找正确的密码，然后然后传入SimpleAuthenticationInfo的构造方法中，也就是1Object accountCredentials = getCredentials(info); 之前这句代码获取的密码。 三、Spring配置做完了上面这些，肯定得与Spring整合了。filterChainDefinitions中可以自定义拦截规则 123456789101112131415161718192021&lt;bean class=\"org.apache.shiro.spring.aop.SpringAnnotationResolver\"/&gt;&lt;bean class=\"cn.blingfeng.commons.shiro.MyCredentialsMatcher\" id=\"credentialsMatcher\"/&gt;&lt;bean class=\"cn.blingfeng.commons.shiro.MyRealm\" id=\"myRealm\"&gt; &lt;property name=\"credentialsMatcher\" ref=\"credentialsMatcher\"/&gt;&lt;/bean&gt;&lt;bean class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\" id=\"securityManager\"&gt; &lt;property name=\"realm\" ref=\"myRealm\"/&gt;&lt;/bean&gt;&lt;bean class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\" id=\"shiroFilter\"&gt; &lt;property name=\"loginUrl\" value=\"/login\"/&gt; &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt; &lt;property name=\"filterChainDefinitions\"&gt; &lt;value&gt; /static/**=anon /login=anon &lt;!--/user/userinfo=authc--&gt; /user/userinfo=anon &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" id=\"lifecycleBeanPostProcessor\"&gt;&lt;/bean&gt; 四、web.xml因为项目默认由SpringMVC来进行拦截管理，所以我们应该让Spring把所有拦截交给Shiro管理（记住，一定要配置在SpringMVC之前，在SpringMVC配置前就交由Shiro管理）1234567891011121314&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;/filter-mapping&gt; 前端也有与Shiro整合的模版语言，jsp，freemarker，velocity都有开源的代码，实现权限标签也是很简单的事.","categories":[{"name":"web","slug":"web","permalink":"http://www.blingfeng.cn/categories/web/"},{"name":"Shiro","slug":"web/Shiro","permalink":"http://www.blingfeng.cn/categories/web/Shiro/"}],"tags":[{"name":"权限，Spring","slug":"权限，Spring","permalink":"http://www.blingfeng.cn/tags/权限，Spring/"}]},{"title":"Activity工作流","slug":"Activity工作流","date":"2017-10-14T04:53:04.000Z","updated":"2017-10-14T04:39:27.932Z","comments":true,"path":"2017/10/14/Activity工作流/","link":"","permalink":"http://www.blingfeng.cn/2017/10/14/Activity工作流/","excerpt":"说到工作流，我们肯定第一时间想到的是JBPM和Activity，JBPM是使用Hibernate来管理数据库的，而Activity则是比较开放的贴近Mybatis的风格。而现在SSH框架用的也是越来越少了，所以Activity取代JBPM也是不远的事。 Activity的github地址:https://github.com/Activiti 一、导入依赖这里使用的是Activity的5.15.1版本123456789101112&lt;!--activity工作流依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.15.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- activiti 与 Spring 集成 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.15.1&lt;/version&gt;&lt;/dependency&gt;","text":"说到工作流，我们肯定第一时间想到的是JBPM和Activity，JBPM是使用Hibernate来管理数据库的，而Activity则是比较开放的贴近Mybatis的风格。而现在SSH框架用的也是越来越少了，所以Activity取代JBPM也是不远的事。 Activity的github地址:https://github.com/Activiti 一、导入依赖这里使用的是Activity的5.15.1版本123456789101112&lt;!--activity工作流依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.15.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- activiti 与 Spring 集成 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.15.1&lt;/version&gt;&lt;/dependency&gt; 二、创建流程图idea里面有流程图的插件:ActBPMFile-&gt;Settings-&gt;Plugins-&gt;搜索 ActBPM -&gt;install接下来创建一个.bmpn文件然后画图= = 三、Spring与Activity整合嗯，接下来和spring的整合 上面注释应该很详细了12345678910111213141516171819202122232425262728293031323334353637&lt;bean class=\"org.activiti.spring.SpringProcessEngineConfiguration\" id=\"processEngineConfiguration\"&gt; &lt;!--配置数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--数据库表更新，若数据库中不存在表，则自动创建--&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\"/&gt; &lt;!--定时工作流--&gt; &lt;property name=\"jobExecutorActivate\" value=\"false\"/&gt; &lt;!--事务管理--&gt; &lt;property name=\"transactionManager\" ref=\"txManager\"/&gt; &lt;!--解决乱码--&gt; &lt;property name=\"activityFontName\" value=\"宋体\"/&gt; &lt;property name=\"labelFontName\" value=\"宋体\"/&gt; &lt;!--部署流程图--&gt; &lt;property name=\"deploymentResources\"&gt; &lt;list&gt; &lt;value&gt;classpath:workflow/*.bmpn&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean class=\"org.activiti.spring.ProcessEngineFactoryBean\" id=\"processEngine\"&gt; &lt;property name=\"processEngineConfiguration\" ref=\"processEngineConfiguration\"/&gt; &lt;/bean&gt; &lt;!--调用processEngin中的方法 对7个服务进行注入 在service层中直接自动注入即可--&gt; &lt;!--任务服务--&gt; &lt;bean id=\"taskService\" factory-bean=\"processEngine\" factory-method=\"getTaskService\"&gt;&lt;/bean&gt; &lt;!--表单服务--&gt; &lt;bean id=\"formService\" factory-bean=\"processEngine\" factory-method=\"getFormService\"&gt;&lt;/bean&gt; &lt;!--历史数据服务--&gt; &lt;bean id=\"historyService\" factory-bean=\"processEngine\" factory-method=\"getHistoryService\"&gt;&lt;/bean&gt; &lt;!--身份认证服务--&gt; &lt;bean id=\"identityService\" factory-bean=\"processEngine\" factory-method=\"getIdentityService\"&gt;&lt;/bean&gt; &lt;!--数据存储服务--&gt; &lt;bean id=\"repositoryService\" factory-bean=\"processEngine\" factory-method=\"getRepositoryService\"&gt;&lt;/bean&gt; &lt;!--管理服务--&gt; &lt;bean id=\"managementService\" factory-bean=\"processEngine\" factory-method=\"getManagementService\"&gt;&lt;/bean&gt; &lt;!--运行时服务--&gt; &lt;bean id=\"runtimeService\" factory-bean=\"processEngine\" factory-method=\"getRuntimeService\"&gt;&lt;/bean&gt; 四、小demo接下来把controller层代码写下 service层调上面注入的bean的方法，写一堆对应你业务逻辑的东西就ok了。小demo有没有你心里没点逼数吗？ヽ(°◇° )ノ","categories":[{"name":"web","slug":"web","permalink":"http://www.blingfeng.cn/categories/web/"},{"name":"Activity","slug":"web/Activity","permalink":"http://www.blingfeng.cn/categories/web/Activity/"}],"tags":[{"name":"工作流","slug":"工作流","permalink":"http://www.blingfeng.cn/tags/工作流/"},{"name":"web后端","slug":"web后端","permalink":"http://www.blingfeng.cn/tags/web后端/"}]},{"title":"linux下zookeeper集群的搭建","slug":"linux下zookeeper集群的搭建","date":"2017-08-05T08:36:50.000Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"2017/08/05/linux下zookeeper集群的搭建/","link":"","permalink":"http://www.blingfeng.cn/2017/08/05/linux下zookeeper集群的搭建/","excerpt":"先把zookeeper的压缩包解压到/usr/root/solr-cloud 然后改个名字复制2份 zookeeper01 zookeeper02 zookeeper03(zookeeper集群最少需要3个zookeeper，因为zookeeper投票选举leader是按超过总数一半来决定的)","text":"先把zookeeper的压缩包解压到/usr/root/solr-cloud 然后改个名字复制2份 zookeeper01 zookeeper02 zookeeper03(zookeeper集群最少需要3个zookeeper，因为zookeeper投票选举leader是按超过总数一半来决定的) 分别在每个zookeeper目录下创建data目录用来保存一些信息 在data目录下创建myid用于保存每个zooekeeper节点的id，用于区分在conf目录下复制一份zoo.simple.cfg 改名为zoo.cfg 然后配置data目录和zookeeper的各节点信息（每个zookeeper目录都需要修改） 创建运行zookeeper的命令 添加权限 运行,Ok","categories":[{"name":"linux","slug":"linux","permalink":"http://www.blingfeng.cn/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.blingfeng.cn/tags/linux/"},{"name":"集群","slug":"集群","permalink":"http://www.blingfeng.cn/tags/集群/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://www.blingfeng.cn/tags/zookeeper/"}]},{"title":"Idea下创建MAVEN工程","slug":"Idea下创建MAVEN工程","date":"2017-07-25T11:05:58.000Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"2017/07/25/Idea下创建MAVEN工程/","link":"","permalink":"http://www.blingfeng.cn/2017/07/25/Idea下创建MAVEN工程/","excerpt":"首先安装MAVEN插件就不说了，那么如何在Idea开发环境下创建一个MAVEN工程呢？","text":"首先安装MAVEN插件就不说了，那么如何在Idea开发环境下创建一个MAVEN工程呢？(1)首先在Idea工具中 File-Settings-Maven中配置我们的MAVEN的插件位置，然后在 Maven home directory中选择Maven的配置文件，若配置文件中没有写本地仓库的位置，那么你还可以选择本地仓库的位置。File-New Project-创建一个Maven工程-next，我们以创建一个web工程为例. 填写组名和项目名以及版本号项目名和位置,点完成看起来似乎少了web目录右键项目名添加框架支持勾选WEB应用，不过不知道为什么我的版本号只能选择3.1……好啦。Idea创建一个Maven工程大致就是这样。","categories":[{"name":"MAVEN","slug":"MAVEN","permalink":"http://www.blingfeng.cn/categories/MAVEN/"}],"tags":[{"name":"Idea","slug":"Idea","permalink":"http://www.blingfeng.cn/tags/Idea/"},{"name":"MAVEN","slug":"MAVEN","permalink":"http://www.blingfeng.cn/tags/MAVEN/"}]},{"title":"hibernate3-Configuration源码学习","slug":"hibernate3-Configuration源码学习","date":"2017-07-10T11:53:04.000Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"2017/07/10/hibernate3-Configuration源码学习/","link":"","permalink":"http://www.blingfeng.cn/2017/07/10/hibernate3-Configuration源码学习/","excerpt":"Configuration作为hibernate的入口，我们有必要研究一下它的源码，首先Configuration中提供了三个configure方法，分别是无参，参数为字符串，参数为URL的方法。1234567891011121314public Configuration configure() throws HibernateException &#123; return this.configure(\"hibernate.cfg.xml\"); &#125; public Configuration configure(String resource) throws HibernateException &#123; this.standardServiceRegistryBuilder.configure(resource); this.properties.putAll(this.standardServiceRegistryBuilder.getSettings()); return this; &#125;public Configuration configure(URL url) throws HibernateException &#123; this.standardServiceRegistryBuilder.configure(url); this.properties.putAll(this.standardServiceRegistryBuilder.getSettings()); return this; &#125;","text":"Configuration作为hibernate的入口，我们有必要研究一下它的源码，首先Configuration中提供了三个configure方法，分别是无参，参数为字符串，参数为URL的方法。1234567891011121314public Configuration configure() throws HibernateException &#123; return this.configure(\"hibernate.cfg.xml\"); &#125; public Configuration configure(String resource) throws HibernateException &#123; this.standardServiceRegistryBuilder.configure(resource); this.properties.putAll(this.standardServiceRegistryBuilder.getSettings()); return this; &#125;public Configuration configure(URL url) throws HibernateException &#123; this.standardServiceRegistryBuilder.configure(url); this.properties.putAll(this.standardServiceRegistryBuilder.getSettings()); return this; &#125; 无参方法体中调用参数为字符串的方法，并将”hibernate.cfg.xml”作为参数传入。那么我们可以直接分析参数为字符串的方法。123public Configuration configure() throws HibernateException &#123; return this.configure(\"hibernate.cfg.xml\"); &#125; 该方法中调用standardServiceRegistryBuilder中的configure方法，将主配置文件名作为参数参入。该方法会调用该类中的参数为LoadedConfig对象的configure方法。loadConfigXmlResource方法中传入主配置文件名。 123public StandardServiceRegistryBuilder configure(String resourceName) &#123; return this.configure(this.configLoader.loadConfigXmlResource(resourceName)); &#125; 该方法会遍历主配置文件，然后将其中的信息用集合储存起来，返回一个LoadedConfig对象。123456789101112131415161718192021public LoadedConfig loadConfigXmlResource(String cfgXmlResourceName) &#123; InputStream stream = ((ClassLoaderService)this.bootstrapServiceRegistry.getService(ClassLoaderService.class)).locateResourceStream(cfgXmlResourceName); if(stream == null) &#123; throw new ConfigurationException(\"Could not locate cfg.xml resource [\" + cfgXmlResourceName + \"]\"); &#125; else &#123; LoadedConfig var4; try &#123; JaxbCfgHibernateConfiguration jaxbCfg = ((JaxbCfgProcessor)this.jaxbProcessorHolder.getValue()).unmarshal(stream, new Origin(SourceType.RESOURCE, cfgXmlResourceName)); var4 = LoadedConfig.consume(jaxbCfg); &#125; finally &#123; try &#123; stream.close(); &#125; catch (IOException var11) &#123; log.debug(\"Unable to close cfg.xml resource stream\", var11); &#125; &#125; return var4; &#125;&#125; 我们回到standardServiceRegistryBuilder类中的configure方法，该方法将LoadedConfig对象作为参数传入。12345public StandardServiceRegistryBuilder configure(LoadedConfig loadedConfig) &#123; this.aggregatedCfgXml.merge(loadedConfig); this.settings.putAll(loadedConfig.getConfigurationValues()); return this; &#125; 调用merge方法将配置文件中信息存储在该aggregatedCfgXml对象中。然后将键值信息保存在settings集合中。123456789101112131415public void merge(LoadedConfig incoming) &#123; if(this.sessionFactoryName != null) &#123; if(incoming.getSessionFactoryName() != null) &#123; log.debugf(\"More than one cfg.xml file attempted to supply SessionFactory name: [%s], [%s]. Keeping initially discovered one [%s]\", this.getSessionFactoryName(), incoming.getSessionFactoryName(), this.getSessionFactoryName()); &#125; &#125; else &#123; this.sessionFactoryName = incoming.getSessionFactoryName(); &#125; this.addConfigurationValues(incoming.getConfigurationValues()); this.addMappingReferences(incoming.getMappingReferences()); this.addCacheRegionDefinitions(incoming.getCacheRegionDefinitions()); this.addJaccPermissions(incoming.getJaccPermissionsByContextId()); this.addEventListeners(incoming.getEventListenerMap()); &#125; 我们返回Configure中的configure(String resource)方法，其将Map集合中的键值信息存储在了properties中，然后返回了该Configuration对象。1this.properties.putAll(this.standardServiceRegistryBuilder.getSettings()); 简单来说说该Configuration的configure主要完成主配置文件信息的加载，将配置信息以键值形式存储在了properties集合中。参数为URL的方法与上述类似。","categories":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.blingfeng.cn/categories/Hibernate/"},{"name":"Configuration","slug":"Hibernate/Configuration","permalink":"http://www.blingfeng.cn/categories/Hibernate/Configuration/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.blingfeng.cn/tags/框架/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.blingfeng.cn/tags/Hibernate/"},{"name":"源码","slug":"源码","permalink":"http://www.blingfeng.cn/tags/源码/"}]},{"title":"Hibernate中对象的三种状态","slug":"Hibernate中对象的三种状态","date":"2017-07-05T11:42:01.000Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"2017/07/05/Hibernate中对象的三种状态/","link":"","permalink":"http://www.blingfeng.cn/2017/07/05/Hibernate中对象的三种状态/","excerpt":"","text":"在hibernate的对象中有三种状态：瞬时状态，持久化状态，游离状态。 当hibernate对象无id，没有与session绑定时，为瞬时状态。 12Product product=new Product();product.setPname(\"联想\");//瞬时状态 当hibernate对象有id且与session绑定时，为持久化状态。123Product product=new Product();product.setPname(\"联想\");session.save(product);//持久化状态 当hibernate对象有id没有与session绑定时为游离状态。12session.save(product);session.close();//游离状态 瞬时状态和游离状态都可转化为持久化状态（save/update）saveOrupdate方法可以让我们不用区分它们的状态。 所以很容易得出当session调用get方法时，获得的对象为持久化状态，当对其进行修改时，会同步到数据库。","categories":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.blingfeng.cn/categories/Hibernate/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.blingfeng.cn/tags/框架/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.blingfeng.cn/tags/Hibernate/"},{"name":"状态","slug":"状态","permalink":"http://www.blingfeng.cn/tags/状态/"}]},{"title":"music","slug":"music","date":"2017-06-24T02:03:42.000Z","updated":"2017-09-29T09:57:32.434Z","comments":true,"path":"2017/06/24/music/","link":"","permalink":"http://www.blingfeng.cn/2017/06/24/music/","excerpt":"囧菌的《哥哥呀》","text":"囧菌的《哥哥呀》 还是囧菌的《Curiosity》 二苼和囧菌的《We Don’t Talk Anymore》 锁那的《言葉のいらない約束》","categories":[{"name":"music","slug":"music","permalink":"http://www.blingfeng.cn/categories/music/"},{"name":"share","slug":"music/share","permalink":"http://www.blingfeng.cn/categories/music/share/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://www.blingfeng.cn/tags/音乐/"},{"name":"封茗囧菌","slug":"封茗囧菌","permalink":"http://www.blingfeng.cn/tags/封茗囧菌/"},{"name":"双苼","slug":"双苼","permalink":"http://www.blingfeng.cn/tags/双苼/"},{"name":"唢那","slug":"唢那","permalink":"http://www.blingfeng.cn/tags/唢那/"}]}]}